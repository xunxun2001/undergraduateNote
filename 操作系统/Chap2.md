# 1. 进程的基本概念

## 1.1 进程的定义（不同角度）

> - 程序作用在一组数据上的一次执行过程（一次计算）
> - 操作系统中一个可独立调度和资源分配的基本单位
> - 可以与其他程序并发执行的程序的一次执行

## 1.2 进程的特征、与程序的区别
> - 动态性
>   - 进程由创建到消亡是有一定生命期的，在生命期间进程是一个活动实体
>   - 而程序是可以永久存放于某种介质上的有序指令集合，是一个静态实体
> - 并发性
>   - 在内存中的多个进程能在一段时间内同时运行
>   - 多个进程的程序可以并发执行,而程序是不能并发执行的
> - 独立性
>   - 进程是一个能够独立运行的基本单位，即只有进程才能被独立调度运行及独立获得资源
>   - 程序是不能作为调度运行和获得资源的基本单位的
> - 异步性
>   - 进程以各自独立的、不可预知的速度向前推进
> - 结构特征
>   - 进程控制块(`PCB`)、程序段、数据段

## 1.3 进程（实体）的组成

> 进程实体是进程的一次快照，进程是一次过程

> - 进程控制块`PCB`
>   - **进程存在的唯一标识**
> - 程序段
> - 数据段


![picture 12](../assets/aaafcefa310d0a6bf71d3edb960fe36ba8898059eab37f5e6567a121fda032af.png)  

![picture 13](../assets/3e89564806fb5807c801d540c6a9f8173fad76c5bc344522a1ebfec0d2c5f97d.png)  


## 1.4 进程状态
> - 不能由阻塞态直接转化为运行态
> - 不能由就绪态直接转为阻塞态

![picture 14](../assets/d5a5ffde0f69a47b77114be6d8f0bb073eb11fe1fa27558a9220b3e7a9efb3ea.png)  
![picture 15](../assets/346b85af06b5f922bd6691984959b6574ed583f5eac3fc46ff5d24c5e47891ef.png)  

# 2. 进程控制与原语
> - 用原语来实现进程控制，具有**原子性**，一气呵成(即操作时要**屏蔽中断**)
> - 如果不具有原子性，可能会导致某些关键数据结构信息不一致
> - 作业：在外存还没运行的程序

![picture 16](../assets/772ca811ec57ae34031ce2465ec1de54886f21a52a1aa7a6af01798fe0382505.png)  
![picture 17](../assets/7764d122eeece6294d3b8f3dc2413559fe62c9efc697ad1b504ed57d397e3765.png)  
## 2.1 创建原语
![picture 20](../assets/c217b95a0ce0706a7cc0ae16a6bf85987efd25c51879316b1566ee7383e86cd6.png)  


## 2.2 撤销原语
![picture 19](../assets/3a96b7fb04f51c421bf08dddca3577642a11728c7298aea4c44279f0c843cafe.png)  

## 2.3 阻塞原语和唤醒原语

![picture 21](../assets/39c911b651b08db66a863983b0679b88b4119d1091de5ec7355ac49aa56dacc3.png)  

## 2.3 切换原语
![picture 23](../assets/7869df9c9dfb792b2a1d2f9da196498eb80e93d5e6df4477d5a397f374765f8b.png)  


# 3. 进程同步与互斥
> - 进程同步————**解决异步**的问题，就是一种**制约关系**
> - **协调**进程之间的**相互制约关系**，达到**资源共享和进程协作**，**避免**进程之间的**冲突**
> - 临界资源：一段时间内只允许一个进程使用
> - 进入区、临界区、退出区、剩余区

![picture 24](../assets/a1c8574b5318eff18188b0bd8a90c72f8fe347a22f438acb3411eb686a00ff62.png)  

![picture 25](../assets/38da5ae85232ad15253265418f7d2741a625fa68e82ebef66eabf2de412c8565.png)  

## 3.1 进程互斥原则


1. 空闲让进：临界区空闲时，允许一个请求进入临界区的进程立即进入临界区
2. 忙则等待：临界区已有进程时，其余进程进入临界区必须等待
3. 有限等待：保证**不会饥饿**，要在**有限时间**内进入
4. 让权等待：若进程不能进入临界区，应立即释放处理机，**防止忙等待**

## 3.2 信号量机制

> 整形信号量不满足让权等待，因此人们提出记录型信号量

![picture 1](../assets/6d95c2415367b88e89bd78fbf894f3c411fa605ef95dfb404e6e08498cdbbd06.png)  

![picture 2](../assets/33235fd26231e06728503451d3a594150601961688eee3907df8248566adc910.png)  


## 3.3 利用信号量实现同步
> - P(S)——申请一个资源`mutex`，资源不够就阻塞等待
> - V(S)——释放一个资源`mutex`，若有进程在等待，唤醒一个进程
> - 不同的临界资源需要设置不同的互斥信号量`mutex`，初始值大于等于`1`
> - 在进入区P(`mutex`)——申请资源
> - 在退出区V(`mutex`)——释放资源

## 3.4 利用信号量实现同步
> 1. 分析在什么地方需要保证“**一前一后**”
> 2. 设置同步信号量`S`，初始值`0`
> 3. **前V后P**：在前操作之后执行`V(S)`，在后操作之前执行`P(S)`


![picture 3](../assets/8f9ace91656039c4b8264933dc6f7186ddc8e6983711bc27898e7e8197f9c4e1.png)  

![picture 4](../assets/c4741a9f7d6089a2b34e44eeadfc9f66fa33655642dc79239684f043bd7790e8.png)  

## 3.5 生产者与消费者问题
> - 实现互斥的P操作一定要在同步的P操作之后
> - V操作顺序可以交换，因为V操作不会导致进程阻塞
![picture 5](../assets/f48f63fea93a366b13619e7e289174047e90f089c2d05cbf9a56b8c7f4627a3f.png)  
![picture 6](../assets/de27b78cd4455c0a0b2179c6295b1c3f11fb6d8a5e9e937c3397fb46fedb2dfc.png)  
![picture 7](../assets/c387faecbe98284ad544137bb55de38d291a004cb2d859f0457148c403fc774f.png)  

## 3.6 多生产者多消费者问题
![picture 8](../assets/2379ca0f7761433e90a6cee7aa8c99688bdecaa4fbce8d6ed0e02f927c36ec0b.png)  

![picture 9](../assets/ae215592694318a1f095a39b1eab7b1a5d7ed7f4a02408ea06475afc7862c0e9.png)  

![picture 10](../assets/19bbd0b8977a1da059a2db91974e47fc3de6a87c8fd26e7cf8a3ed7871b34cee.png)  
![picture 11](../assets/8c6cb4962c1b8d29e3f5d16eec6aaef25717e7e66b2b4b03341b26a0649e1181.png)  

# 4. 线程
## 4.1 线程与进程
> - 进程作为一个独立运行的基本单位——只有进程可以被调度运行，只有进程才能拥有资源
> 
> - 为使进程的程序充分并发执行，同时能尽量减少系统的开销
>   - 分配、回收、切换 —— 时空开销
> - 进程**调度运行**和**拥有资源**这两个基本运行单位的属性分开，**让进程拥有资源**，而让一个**线程作为调度运行的基本单位**
> 
> - 在引入线程的操作系统中，将**进程**看作**资源集合与线程集合**的复合体

![picture 13](../assets/c9931f37bf1c5c9e0b98c259c363800f64403bfb575d2505d53a33fa9d3eb094.png)  

![picture 14](../assets/164cbf48f8ad2a9eeb05a8d6333b4a9da1f448ddbd0c689c885187658ddaa3e6.png)  

## 4.2 线程的类型

### a.用户级线程

> - 用户自己创建的**逻辑上的线程**
> - 多对一模型

![picture 15](../assets/135d427f2ab05105e8626f915f9c890544685ff9f5d0b92846811c0ef37fff2f.png)  

### b.内核级线程
> - 一对一模型
 ![picture 16](../assets/6f1f0de40e9e8f85d31fca708d147902433b3c748551d71f29a25509b73e4b04.png)  


### c.多对多模型

![picture 17](../assets/f6f682f0529a09ab07095dec325bb020ac3b1dfd3e041832fc537ab2367698d6.png)  
