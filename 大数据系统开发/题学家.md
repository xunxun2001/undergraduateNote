# Chap 1
> - 大数据带来思维方式的三个转变是
>   - 相关而非因果
>   - 全样而非抽样
>   - 效率而非精确
> - 大数据发展的三个阶段
>   - 萌芽期
>   - 成熟期
>   - 大规模应用期
> - 数据产生方式大致经历了三个阶段
>   - 运营式系统阶段
>   - 感知式系统阶段
>   - 用户原创内容阶段

![picture 1](../assets/4ac79f1638441d48d8daa0f19de77ea93fbfe2d195ab018fc6765ba5ce835978.png)  

![picture 2](../assets/5eb2f11e06e17309afefb8c0023ae6c76c22f7d35c40f61bb5c8f7d7f0854728.png)  

![picture 3](../assets/9730ea6cc5f20195d5358f7153ea335fd8c7e821b83c9cbae4f44df8bfbb4864.png)  

![picture 4](../assets/0c6b0cec23d476a6ea7432ce1ea8f69cfa4bb1f62a182f87b8cd1c260a3909bd.png)  


> - 批处理框架
>   - `Hive`
>   - `MapReduce`
> - 基于历史数据的交互式查询
>   - `Impala`
>   - `Dremel`
>   - `Spark SQL`
> - 实时数据处理
>   - `S4`
>   - `Storm`
>   - `Spark Streaming`
> - 图结构
>   - `Pregel`
>   - `GraphX`

![picture 5](../assets/8fa2c9b04ecfce915d30f3cb20872cb29e137132eb942d60799a40c25a3f4274.png)  
![picture 6](../assets/58ad94592eebc41543eee9f037d91cdc2dc36f7eb7b6af81f9b26b81859881ed.png)  

![picture 7](../assets/00b9308516300e3fa438a816d41bcefb45c7d5b1c887984b446737b62fdf55e9.png)  

![picture 8](../assets/5610eaf3d9a382868a1dbb234171eafec2f69f7aed4ca4624e8e103113e3f7b7.png)  

![picture 9](../assets/a2cbc765fafe3ac255c361de698cd9ef511c3251eb94daba08f96ea5851d4b1b.png)  



# Chap 2
![picture 15](../assets/8e0830247394305edb1385587209df7b46f5ddeb8f767f08ff21f9861c477d66.png)  

![picture 16](../assets/831efa448505491441faea4e4441d8fbce6bcd0b6e4bc6162dca9982c6a627d3.png)  

![picture 17](../assets/b6166c96b704a1235e56160e24abe4036fcb8cbd2752ea189ee38c6f9972e6bb.png)  

![picture 18](../assets/308a9fd408ed328117555ad8568fa12f84b7e01ceefb76bb02bb86de6061fd25.png)  

![picture 19](../assets/7253c5a8e15540e41d1de28f75afda388e46c103aed10e4d77f145f3adf9210b.png)  
![picture 20](../assets/9192e08c731854fc63884461135748435fbf92e602ae59655d9d7678eba0fbb0.png)  

![picture 21](../assets/604ecc960d253e64be80325cfb1bd79e5e9e34a615972d8c4e509753acd9ca75.png)  

![picture 22](../assets/02f1c705cb5f56ea54cf27af67454609804251a325e4306f0d356fd5d6542a2b.png)  

![picture 23](../assets/180fb52597272651af890c441127035f87a727279f17b978938605177b5591ac.png)  

![picture 24](../assets/aa78921074e5b336081c4145d189d6066fc59696f0646e7abcd963d4ea1502b6.png)  

![picture 25](../assets/e5eaed5e2ec4a06e27d5828a74b1f254f8764aa49055f157e95b05c10f99fa3c.png)  


> - **命令式**编程：`C++`、`Java`等面向对象程序编程语言
>   - 完全根植于冯诺依曼体系结构
>   - 涉及多线程之间的状态共享，需要**锁机制**
> - **函数式**编程（泛函编程）：`Haskell`、`Erlang`和`Lisp`等语言
>   - 充分利用多核CPU的并发能力
>     - 不会在多个线程之间共享状态，不需要用锁机制
> - 大数据时代也是多核CPU时代，因此函数式编程（泛函编程） 
> - `Scala`
>   - 类`Java`的多范式语言，它整合了面向对象编程和函数式编程的最佳特性
>   - 运行于`Java`虚拟机（`JVM`）之上兼容现有的`Java`程序

```SCALA
for (变量 <- 表达式) {语句块}

for(i<-1 to 5;j<-1 to 10) println(i*j)
```

```SCALA
for (变量 <- 表达式) yield {语句块}

val r=for (i <- Array(1,2,3,4,5) if i%2==0) yield { println(i); i}
//2
//4
//r: Array[Int] = Array(2,4)
```

```
import java.io.FileReader 
import java.io.FileNotFoundException 
import java.io.IOException 
try { 
  val f = new FileReader("input.txt") // 文件操作 
} catch { 
  case ex: FileNotFoundException => // 文件不存在时的操作 
  case ex: IOException => // 发生I/O错误时的操作
} finally { 
  file.close() // 确保关闭文件 
} 
```
```SCALA
import util.control.Breaks._ //导入Breaks类的所有方法
val array = Array(1,3,10,5,4)
breakable{
for(i<- array){
       if(i>5) break //跳出breakable，终止for循环，相当于Java中的break
       println(i)
    }
}
// 上面的for语句将输出1，3
```
```SCALA
for(i<- array){
    breakable{
        if(i>5) break  //跳出breakable，终止当次循环
                        //相当于Java的continue    
        println(i)    
    }
}// 上面的for语句将输出1，3，5，4
```
```SCALA
val otherList="Apache"::strList
//执行该语句后strList保持不变，而otherList将成为一个新的列表：
//List("Apache","BigData","Hadoop","Spark")

```
![picture 14](../assets/e81fc0473e709385fa24741e89bed684d26681d2e3ab9ce79c9c26ab583d31e4.png)  
```SCALA
//缺省情况下创建的是不可变集
var mySet = Set("Hadoop","Spark")
mySet += "Scala" 

//如果要声明一个可变集，则需要提前引入scala.collection.mutable.Set
import scala.collection.mutable.Set
val myMutableSet = Set("Database","BigData")
myMutableSet += "Cloud Computing" 
```
```SCALA
val university = Map("XMU" -> "Xiamen University", "THU" -> "Tsinghua University","PKU"->"Peking University")
//如果要获取映射中的值，可以通过键来获取
println(university("XMU"))

//如果给定的键不存在，则会抛出异常，为此，访问前可以先调用contains方法确定键是否存在
val xmu = if (university.contains("XMU")) university("XMU") else 0 println(xmu)


//可变的映射
import scala.collection.mutable.Map
val university2 = Map("XMU" -> "Xiamen University", "THU" -> "Tsinghua University","PKU"->"Peking University")
university2("XMU") = "Ximan University" //更新已有元素的值
university2("FZU") = "Fuzhou University" //添加新元素

//也可以使用+=操作来添加新的元素
university2 + = ("TJU"->"Tianjin University") //添加一个新元素
university2 + = ("SDU"->"Shandong University","WHU"->"Wuhan University") //同时添加两个新元素



```

> 类成员的可见性
> 
> - `Scala`也提供`private`和`protected`
>   - `private`成员只对本类型和嵌套类型可见；
>   - `protected`成员对本类型和其继承类型都可见
>   - Scala采用类似Java中的getter和setter方法，定义了两个成对的方法`value`和`value_=`进行读取和修改
>     - 编译器看到以`value`和`value_=`这种成对形式出现的方法时，它允许用户去掉下划线`_`，而采用类似赋值表达式的形式 
![picture 10](../assets/b793585ad8004384cd112a03c0c9c41407db6dc952efc12d9855c837d1e00e7c.png)  

> 单例对象
> - Scala采用单例对象（singleton object）来实现与Java静态成员同样的功能
> - 使用object 关键字定义<mark>单例对象</mark>
> - 当一个单例对象和它的同名类一起出现时，这时的单例对象被称为这个同名类的<mark>“`伴生对象`”</mark>，相应的类被称为这个单例对象的<mark>“`伴生类`”</mark>
> - 没有同名类的单例对象，被称为<mark>`孤立对象`</mark>。一般情况下，`Scala`程序的入口点`main`方法就是定义在一个孤立对象里
```SCALA
class Person(val name:String){
    private val id = Person.newPersonId() //调用了伴生对象中的方法
    def info() {
        printf("The id of %s is %d.\n",name,id)
    }
}
object Person {
    private var lastId = 0  //一个人的身份编号
    def newPersonId() = {
        lastId +=1
        lastId
    }
    def main(args: Array[String]) {
        val person1 = new Person("Lilei")
        val person2 = new Person("Hanmei")
        person1.info()     //调用了伴生类中的方法
        person2.info()
    }
}
//输出：
//The id of Lilei is 1.
//The id of Hanmei is 2.

```
> `apply`方法
> - `伴生对象`中的`apply`方法
>   - 将所有类的构造方法以`apply`方法的形式定义在伴生对象中，这样伴生对象就像生成类实例的工厂，而这些`apply`方法也被称为**工厂方法**
> - 为什么要设计apply方法？
>   - **保持对象和函数之间使用的一致性**
>     - 面向对象：“`对象.方法`” 
>     - 数学：“`函数(参数)`”
>     - `Scala`中一切都是对象，包括函数也是对象。`Scala`中的函数既保留括号调用样式，也可以使用点号调用形式，其对应的方法名即为`apply`

```SCALA
trait Flyable {
       var maxFlyHeight:Int  //抽象字段
       def fly() //抽象方法
       def breathe(){ //具体的方法
             println("I can breathe")
       }
 }
trait HasLegs {
       val legs:Int   //抽象字段
       def move(){printf("I can walk with %d legs",legs)}
}
class Animal(val category:String){
       def info(){println("This is a "+category)}
}
class Bird(flyHeight:Int) extends Animal("Bird") with Flyable with HasLegs{
         var maxFlyHeight:Int = flyHeight //重载特质的抽象字段
         val legs=2 //重载特质的抽象字段
         def fly(){
               printf("I can fly at the height of %d",maxFlyHeight)
         }//重载特质的抽象方法
}

```
```SCALA
case class Car(brand: String, price: Int) 
val myBYDCar = Car("BYD", 89000)
val myBMWCar = Car("BMW", 1200000)
val myBenzCar = Car("Benz", 1500000)
for (car <- List(myBYDCar, myBMWCar, myBenzCar)) {
       car match{
              case Car("BYD", 89000) => println("Hello, BYD!")
              case Car("BMW", 1200000) => println("Hello, BMW!")
              case Car(brand, price) => println(“Brand:”+ brand +“, Price:”+price+“, do you want it?”)   
       }
 }

/*输出
Hello, BYD!
Hello, BMW!
Brand:Benz, Price:1500000, do you want it?
*/
```
```SCALA
def sum(f: Int => Int, a: Int, b: Int):Int = {
	if(a > b) 0 else f(a) + sum(f, a+1, b)
}

val a = sum(x=>x,1,5) //直接传入一个匿名函数
val b = sum(x=>x*x,1,5) //直接传入另一个匿名函数

val c = sum(powerOfTwo,1,5) //传入一个已经定义好的方法
```
```SCALA
val university = Map("XMU" ->"Xiamen University", "THU" ->"Tsinghua University","PKU"->"Peking University")

university foreach{kv => println(kv._1+":"+kv._2)}
//简化写法
university foreach{x=>x match {case (k,v) => println(k+":"+v)}}
//更加简化
university foreach{case (k,v) => println(k+":"+v)}

```
> - `fold`方法
>   - 比起`reduce`，提供了初始值
>   - 一个双参数列表的函数，从提供的初始值开始规约
>     - 第一个参数列表接受一个规约的初始值，第二个参数列表接受与reduce中一样的二元函数参数
> - `foldLeft`和`foldRight`
>   - 前者从左到右进行遍历，后者从右到左进行遍历
> - `WordCount`
>   - `.flatMap(_.split(" "))`
>   - `.map(x=>(x,1))`
>   - `.reduceByKey(_+_)`


![picture 26](../assets/1c1c491cd85da05a92018ae14f1bb53803f7bacaea10f8dff51d1bdc5ab8be80.png)  

![picture 27](../assets/3a51e47f55b4d49230438f5d41c07a34da41ac5b6c1be5dc51189e1eb97906d6.png)  

![picture 28](../assets/69dbbdd5706a7cc65157983f7308776bceb4fa0392347f4bd9fcf70e4211f305.png)  

![picture 29](../assets/013e7deb054d57c3ed30b7e6e7eb490488a2fc45e282ae72bf3a99b5008cea91.png)  

![picture 30](../assets/99ae0cefbf8a0cf90eef7e73a256a602eec8265a6cd7f1ee9dfbf59a2d2cfb72.png)  

![picture 31](../assets/100f4eae7f64a919d34996cb343a3968eb93f23468e77c8475ea60f5a30ba474.png)  

![picture 32](../assets/6a594da813ce4eb23518019acfbc1982af22398588e6430f20c5b0013810d932.png)  

![picture 33](../assets/b076b59113f90ab3d5986f81d03dde3e16274e2198cad246bcf760fa04ac5c10.png)  

![picture 34](../assets/500d6c849087b5770890b8ada4ff89993bc5b9c67710ddc0d5082d552319a873.png)  

![picture 35](../assets/eb751dfc409f4bafb69078f42da536ef2215edee332e097db7c44c1f46ca5c2a.png)  

![picture 36](../assets/c8fc9bb9c0f85b54073f320c45aad06c19119af8f99ed2e62198aef9701ff5cc.png)  

![picture 37](../assets/ab60b2b6a0069030c5504ddd4de2564a6ffb518445dcc934bdd432240498637a.png)  

![picture 38](../assets/d824de811d764a72a3b77491b91a373f11f5bf1eb2906cb287001d8abcdea106.png)  


# CHAP 3
